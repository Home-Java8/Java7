
Программирование линейных алгоритмов
====================================
* `Вариант #2`: [http://vunivere.ru/work1339](http://vunivere.ru/work1339)



.
===================================
Утилита - это (простая) программа, которое запускается/выполняется в консоле Операционной Системы. Утилита - не имеет графических интерфейсов...
В консоле Операционной Системы можно запустить только 1-утилиту (программу). Для запуска нескольких программ-утилит их нужно запускать в нескольких консолях (отдельно).

Web-приложение - это программа работой которой управляет web-контерйнер.
                 Может существовать большое количество web-клиентов, которые запрашивают у web-контерйнера доступ к программе (web-приложению).
                 Web-контерйнер создает множество потоков этой программы и выполняет ее в отдельном потоке для каждого клиента отдельно!


Что происходит при запуске и выполнении программы:
1.0 Данные-инструкции программы (который присутствует только в одном экземпляре) считываются из носителя информации (диска) и загружаются в область оперативной памяти.
1.1 Каждая новая/повторно запущенная программа будет загружаются в новую/другую область оперативной памяти.

Плюсы такого способа в том, что - данные-переменные разных программ всегда будут находиться в разных областях и никокда небудут пересекаться...
Минусы такого способа в том, что - для работы в многопользовательском режиме та же самая программа запущенная несколько раз будет загружена в несколько разных областей 
                                   оперативной памяти. То есть, это привидит к большому расходу рессурсов!

В многопоточном программировании (ресурс) программа загруженная в одну область оперативной памяти - является (единственной) общей для разных нескольких пользователей!

Плюсы такого способа в том, что - это привидит к экономии, эфективности использованию рессурсов!
Минусы такого способа в том, что - при паралельной работе программы могут/будут возникать ошибки доступа к критическим секциям

После загрузки программных инструкций из носителя информации (файла) в область оперативной памяти процессору нужно сказать чтобы он начал выполнять эту программу.
Для этого выделяется-регистрируется (процессорное) время на выполнение этой программы - это называется созданием потока.

Метод 'main()' является главным методом в программе, который (по умолчанию внутренними средствами JVM) создает 'основной поток' (главным потоком программы) для выполнения программы.
То есть, обычно программа (утилита) выполняется одно-поточном режиме.
Все остальные потоки, которые будут порождены изнутри метод 'main()' называются - побочными потоками (дочерние-порожденные потоки)


.
===================================
Атомарность - это когда операция может завершиться за 1-проход (1-инструкция процессора).

JVM (Виртуальная Машина Java) имеет собственый Java-процессор, который выполняет байт-код в качестве инструкция процессора...

В многопоточной среде задействованы несколько ядер-процессоров. Поэтому в многопоточной среде память делиться на:
- (память) локальный кеш потока
- и основная память
Поэтому в многопоточной среде любая атомарная операция всегда будет выполняться в 2-прохода (данные должны перейти с локального кеша потока в основную память...), нет
никакой гарантии в каком порядке будут вызваны потоки и выполнены эти инструкции.

'volatile' - минует локальный кеш потока и позволяет писать/читать данные прямо из основной памяти. В этом случае мы получаем выиграш по времени!

# http://java-se-learning.blogspot.com/2014/04/java.html
Java потдеждивает два подхода к синхронизации:
- `взаимного сиключения (mutual exclusion)`: каждый блок и функция обозначается аттрибутом synchronized - в этом случае только один поток использует его, а все остальные ожидают его.
- `кооперации (cooperation)`: здесь используется synchronized + wait()/notify() - позволяет потокам сотрудничать между собой, незаставляя при этом ждать полного выполнения и своей очереди...

В качестве 'объекта-монитора' может выступать:
1. Глобальный объект - в случает когда явно передаем этот объект...
2. Текущий объект ('this') - либо егоможно явно указать, либо он передается по умолчанию (если ничего неуказывать)...
3. Класс (статический) - это в случае когда используется статический класс...

# http://habrahabr.ru/post/108016/
# http://cheremin.blogspot.com/2010/03/synchronized-synchronizedthis.html
При выполнении синхронизации функции:
- Компилятор автоматически проставляет флаг-блокировки ('ACC_SYNCHRONIZED') функции на объект. И компилятор не будет вставлять инструкции, на выходе и выходе из этого метода, для захвата и освобождения монитора.
- Уже на стадии выполнения кода, JVM фиксирует наличие этого флага, и автоматически выполняет требуемый захват и освобождение монитора (устанавливает блокировку на объект, вызывает метод и после выполнения этого метода снимает блокировку).
- (Если вылетает исключение, тогда поток автоматически снимает блокировку. Лок держится на время исполнения всего метода)
При выполнении синхронизации блока:
- Компилятор обходит встроенную в JVM поддержку запросов-блокировок объекта и обработку исключений - это (необходимо) описывается явно в байт-коде.
- (Лок заватить только в том месте или в условии где именно нужна синхронизация, а все что вне блока будет исполняться без захватов И даст другим потокам большую свободу действия)


Начитнать изучения языка программирования Java лучше с потоков...
=================================================================
* `/usr/lib/jvm/jdk1.7.0_25/bin/javap -c LinearAlgorithm.class`

# http://darkraha.com/rus/java/api/multithread/index.php
* `Процесс`: когда программные данные (инструкции процессору) загружаются из новителя информации (диска) в область оперативной памяти И занимают там определенное место
* `Поток`: это (процессорное) время которое выделяется процессору на выполнение процесса (программы загруженной о область оперативной памяти)
* `Критические секции`: в многопоточном приложении есть общие ресурсы (переменные-данные). Когда одновременно-паралельно разные потоки получат доступ к общему ресурсу - есть вероятность что данные могут быть утеряны (пока один поток что-то делает, второй поток изменяет даныне)
   Решить проблему доступа к 'критическим секциям' помогает 'механизм синхронизации' (блокировка потоков)
* `Атомарность`: это когда операция может завершиться за 1-проход (1-инструкция процессора, это противоположность 'механизму синхронизации'). В многопоточной программе память (ОЗУ) будет разделена на 'основную память' и 'локальный кеш потока'. Такой промежуточный способ доступа к общему ресурсу имеет вероятность что данные могут быть утеряны (пока один поток использует устаревшие данные, которые небыли обновлены в кеше)
   Решить проблему доступа к атомарным операциям можно с помощью прямого доступа к 'основной памяти' (исключение локального кеша потока)


Потоки представляют собой псевдо-объект (который дублирует поведения одного и того же объекта много раз...).
Потоки создаются для идентичных объектов, которые имеют (один) тот-же самый конструктор.
Если конструкторы создаваемых объектов разные - это значит что объекты тоже будут разные (количество таких-разных объектов невозможно плодить-умножать с помощью потоков).
А в процессе выполнения потока - состояние объекта изменяется.

> Если есть два разных класса-объекта И порядок их вызова (действий) нужно синхронизировать между собой (в строгом порядке...) - тогда в этом случае нужно создавать глобальную переменную 
объект-монитор И с помощью конструкции 'wait()/notify()' управлять порядком вызова БЛОКА...
>> глобальные переменные (а также объекты-мониторы) они тем плохи что может-быть где-то внутренняя переменная с таким-же назвванием может переопределить состояние для глобальной переменной.
По этой причине иногда такие глобальные объекты делают 'final' (неизменяемыми).
>>> Но лучше всего, если в многопоточной задаче присутствует очереди блокировок (например: обмен сообщениями) в которых используется конструкция 'wait()/notify()' - в этом случае лучше 
использовать стандартные решения из библиотеки 'cuncurent'

> Если есть множество самостоятельных-схожих классов-объектов, которые вызывают общий (критический) ресурс-ФУНКЦИЮ в независимом порядке - тогда можно в качестве объекта-монитора сделать 
текущий объект ('this')...

> Еще из той-же библиотеки 'cuncurent' есть классы для работы с атомарными типами. Поскольку Java-32/64 негарантирует атомарность в разных реализациях JVM - в этом случае лучше конечно 
использовать 'cuncurent'

Атомарность гарантирует что при вызове метода 'set()' в 1-проходе для одного потока и вызове метода 'get()' в 2-проходе для другого потока - изменения будут видны и валидны для всех потоков!
(такие классы являются бинами, которые содержат только атомарные методы: ГЕТ-еры и СЕТ-еры)
Например: таким способом класс-бин гарантирует валидность работы методов в многопоточной программе;
          А также это может быть и спосок состоящий из объектов-бинов;
 
Статический класс использовать в многопоточной программе нет смысла, это работать небудет, потому-что статический класс-объек существует только в единственном экземпляре.
На поле с модификатором 'final' нет смысла использовать 'volatile' в многопоточной программе, потому-что здесь неожидается модификаций состояния.

'Синхронизация' - обеспечивает атомарность для сложных блоков и функций-поведений.
Синхронизация всегда блокирует участок кода (функцию и блок) относительно 'монитора'.
'Монитор' - это такой глобальный объект (может иметь только одного владельца) относительно которого происходит блокировка потоков.
Следует отметить что объект-монитор является глобальной переменной для всех побочных-дочерних потоков (относительно основного потока).







* [http://cybern.ru/urok-14-atomarnye-operacii-volatile.html](http://cybern.ru/urok-14-atomarnye-operacii-volatile.html)
* [http://www.quizful.net/interview/java/atomicity-in-java](http://www.quizful.net/interview/java/atomicity-in-java)
* [http://please.noroutine.me/2011/08/atomic.html](http://please.noroutine.me/2011/08/atomic.html)
* [https://bitbucket.org/uitslabs/edu-java-systems/wiki/06-Atomics.md](https://bitbucket.org/uitslabs/edu-java-systems/wiki/06-Atomics.md)


* [http://darkraha.com/rus/java/api/multithread/index.php](http://darkraha.com/rus/java/api/multithread/index.php)
* [http://habrahabr.ru/post/108016/](http://habrahabr.ru/post/108016/)
* [http://cheremin.blogspot.com/2010/03/synchronized-synchronizedthis.html](http://cheremin.blogspot.com/2010/03/synchronized-synchronizedthis.html)
* [http://java-se-learning.blogspot.com/2014/04/java.html](http://java-se-learning.blogspot.com/2014/04/java.html)
* [https://dev.by/lenta/main/pochemu-oni-ne-umeyut-pisat-mnogopotochnye-programmy](https://dev.by/lenta/main/pochemu-oni-ne-umeyut-pisat-mnogopotochnye-programmy)
* [https://ru.wikipedia.org/wiki/Многопоточность](https://ru.wikipedia.org/wiki/Многопоточность)
* [http://programmersnook.blogspot.com/2012/05/java.html](http://programmersnook.blogspot.com/2012/05/java.html)


* [https://www.ibm.com/developerworks/ru/library/j-5things5/](https://www.ibm.com/developerworks/ru/library/j-5things5/)  [https://www.ibm.com/developerworks/ru/library/j-5things5/j-5things5-pdf.pdf](https://www.ibm.com/developerworks/ru/library/j-5things5/j-5things5-pdf.pdf)
* [http://www.javenue.info/post/81](http://www.javenue.info/post/81)


* [http://cs.mipt.ru/docs/courses/osstud/06/ch6.htm](http://cs.mipt.ru/docs/courses/osstud/06/ch6.htm)
* [https://rsdn.ru/forum/java/3622844.flat](https://rsdn.ru/forum/java/3622844.flat)
* [http://info.javarush.ru/translation/2015/02/15/Перевод-Топ-50-интервью-вопросов-по-нитям-Часть-2-.htm](http://info.javarush.ru/translation/2015/02/15/Перевод-Топ-50-интервью-вопросов-по-нитям-Часть-2-.htm)
* [http://www.cyberforum.ru/java-j2se/thread1140751.html](http://www.cyberforum.ru/java-j2se/thread1140751.html)
* [https://ru.wikipedia.org/wiki/Параллелизм_в_Java](https://ru.wikipedia.org/wiki/Параллелизм_в_Java)
* [http://sandro-omsk.livejournal.com/6622.html](http://sandro-omsk.livejournal.com/6622.html)
* [http://alfalavista.ru/index.php/2013-06-18-22-25-47/284-java-many](http://alfalavista.ru/index.php/2013-06-18-22-25-47/284-java-many)
* [http://alfalavista.ru/index.php/2013-06-18-22-25-47/363-potoki-java](http://alfalavista.ru/index.php/2013-06-18-22-25-47/363-potoki-java)
* [http://www.bsu.by/Cache/pdf/508353.pdf](http://www.bsu.by/Cache/pdf/508353.pdf)



* [https://www.ibm.com/developerworks/ru/library/j-jtp11234/](https://www.ibm.com/developerworks/ru/library/j-jtp11234/)
* [http://www.sql.ru/forum/781245/atomarnye-operacii](http://www.sql.ru/forum/781245/atomarnye-operacii)
* [http://ru.stackoverflow.com/questions/313032/java-atomic-переменные-такие-уж-атомарные](http://ru.stackoverflow.com/questions/313032/java-atomic-переменные-такие-уж-атомарные)
* [http://spec-zone.ru/RU/Java/Tutorials/essential/concurrency/atomicvars.html](http://spec-zone.ru/RU/Java/Tutorials/essential/concurrency/atomicvars.html)



