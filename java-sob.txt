В общем типичные вопросы на собеседованиях по вакансии Junior Java Developer и мои ответы на них.

= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
1.Приведите несколько причин почему вы именно выбрали Java?

- Встроенная поддержка многопоточности;
- Автоматическая сборка мусора;
- Объектно-ориентированный язык;
- Возможность создание веб приложений.

=================================================================================================
1. Каковы основные различия между платформой Java и другими программными платформи?

- Платформа java работает поверх других аппатарных платформ.
- Платформа Java имеет 2 составляющие:
-- Java Virtual Machine (JVM) - "JVM" представляет собой программу, переносимую на различные аппаратные платформы. Байт код является машинным языком JVM.
-- Java Application Programming Interface (API Java)


2. В чем разница между C + + и Java?

- В джаве отказались от указателей, указатели по своей природе сложны в ипользовании, а в джава стремились все упростить.
- Джава не поддерживает множественного наследования, так как оно порождает больше проблем чем решает. Вместо этого в джаве можно реализовывать множественное наследование интерфейсов.
- Джава не поддерживает деструкторы, но имеется метод finallyze(). Данный метод сборщик мусора вызывает перед освобождением памяти. Не рекомендуется использовать этот метод для освобождения ресурсов, так как мы не знаем когда сборщик мусора вызовет этот метод.
- Весь джава код заключен в классах, в джаве нет глобальных переменных и функций.
- С++ предполагает ручное управление памятью, в то время как в джава присутствует автоматический сборщик мусора.


3.1 Расскажите про классы-загрузчики и про динамическую зарузку классов?

Любой класс, используемый в джава программу так или иначе был загружен в контекст программы каким-то загрузчиком.
Все виртуальные машины джава включают хотябы один загрузчик классов, так называем базовый загрузчик. Он загружает все основные классы, это классы из rt.jar. Интересно то, что этот загрузчик никак не связан с программой, тоесть мы не можем получить например у java.lang.Object имя зарузчика, метод getClassLoader() вернет нам null.

Следующий загрузчик – это загрузчик расширений, он загружает классы из $JAVA_HOME/lib/ext.

Далее по иерархии идет системный загрузчик, он загружает классы, путь к которым указан в переменной CLASSPATH.

Для примера предположим что у нас есть некий пользовательский класс 'MyClass' и мы его используем. Как идет его загрузка...:
Сначала системный загрузчик пытается найти его в своем кэше загрузок его, если найден – класс успешно загружается, иначе управление загрузкой передается загрузчику расширений, он также проверяет свой кэш загрузок и в случае неудачи передает задачу базовому загрузчику. Тот проверяет кэш и в случае неудачи пытается его загрузить, если загрузка прошла успешно – загрузка закончена. Если нет – передает управление загрузчику расширений. Загрузчик расширений пытается загрузить класс и в случае неудачи передает это дело системному загрузчику. Системный загрузчик пытается загрузить класс и в случае неудачи возбуждается исключение java.lang.ClassNotFoundException.
Вот так работает загрузка классов в джава. Так называемое делегирование загрузки.

Если в системе присутствуют пользовательские загрузики, то они должны быть унаследованы от класса java.lang.ClassLoader .


3.2 Что же такое статическая и что такое динамическая загрузка класса?

- Статическая загрузка класса происходит при использовании оператора «new»
- Динамическая загрузка происходит «на лету» в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса).


3.3 Для чего нужна динамическая загрузка?

Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().


4. Для чего в джаве статические блоки?

Статические блоки в джава выполняются до выполнения конструктора, с помощью них инициализируют статические поля к примеру:
static final int i;
static{
   i=10;
}

Еще один ньюанс, блок статической инициализации может создаваться сам при компиляции программы, например:
public static int MAX=100;

Будет создан код:
public static int MAX;
static{
   MAX=100;
}


5. В чем преимущества объектно-ориентированных языков программирования?

Они представляют реальные объекты в жизни, например, Машина, Джип, Счет в банке и т.д.
Инкапсуляция, наследование и полиморфизм делает его еще мощнее.


6. Как использование объектно – ориентерованного подхода улучшает разработку программного обеспечения?

Основные преимущества:
- (наследование) повторное использование кода;
- реальное отображение предметной области. Объекты соответствуют реальному миру(см. предыдущий пункт).


7. Имеется выражение «является» и «имеет». Что они подразумевают в плане принципов ООП? В чем разница между композицией и агрегацией?

«является» - наследование
«имеет» - композиция

В качестве примера предположим что у нас есть классы 'Строение', 'Дом' и 'Ванная комната'. Так вот 'Дом' является 'строением', что нельзя сказать про 'Ванну', которая не является 'домом'. А вот 'Дом' имеет/включает в себя 'Ванну'.
Если вы хотите использовать повторно код, то не обязательно использовать наследование. Если нет отношения «является», то лучше тогда использовать композицию для повторного использования кода.
Не используйте наследование для получение полиморфизма, если нет ключевой зависимости «является». Используйте интерфейсы для полиморфизма.

Из спецификации можно узнать, что:
- "Ассоциация" обозначает связь между объектами.
- "Агрегация и композиция" это частные случаи ассоциации.
- "Агрегация" предполагает, что объекты связаны взаимоотношением "part-of" (часть).
- "Композиция" более строгий вариант агрегации. Дополнительно к требованию part-of накладывается условие, что "часть" не может одновременно принадлежать разным "хозяевам", и заканчивает своё существование вместе с владельцем. Например:
-- мотоцикл -> cумка с багажём - "ассоциация". Отношение "имеет".
-- мотоцикл -> колесо - "композиция".
-- группа по интересам -> человек - "агрегация". человек часть группы, но может принадлежать нескольким разным группам.


8.1 Что вы подразумеваете под полиморфизмом, инкапсуляцией и динамическим связыванием?

Полиморфизм означает способность переменно данного типа, которая ссылается на объекты разных типов, при этом вызывается метод, характерный для конкретного типа ссылки на объект.


8.2 В чем преимущество полиморфизма?

Он позволяет добавлять новые классы производных объектов, не нарушая при этом код вызова.
Также использование полиморфизма называют динамическим связыванием объектов.

Рассмотрим пример полиморфизма:
- Имеется классы: Фигура, круг и треугольник.
- Круг и треугольник наследуется от фигуры соответственно.
- Каждый класс имеет метод «рисовать». В круге и треугольнике этот метод переопределен.
- Так вот, создаем объект с типом «Фигура» и присваиваем ей ссылку на объект типа «Круг» и вызываем на этом объекте метод «рисовать». В итоге вызывается метод класса «Круг», а не класса «Фигура» как ожидалось:
  Shape s = new Circle();
  s.draw();

Также вместо класса родителя «Фигура» к примеру можно использовать интерфейс «Фигура», определив там метод 'рисовать'. Этот интерфейс мы имплементируем в классах «Круг» и «Треугольник». Далее на интерфейсе создаем объект и присваиваем ему ссылку на объект какого-то из реализующих этот интерфейс классов.

Это удобно например если у нас есть некий метод:
public void drawShape(Shape s){
   s.draw();
}

Обратите внимание что в метод мы передаем параметр с типом интерфейса, т.е. мы не знаем какой именно тип объекта будем, но реализация будет таже. Далее мы можем просто создать еще класс, к примеру «Трапеция», имплементировать и  интерфейс «Фигура» и просто передать экземпляр класса в метод, ничего не меняя в реализации и вызове.

Наследование это включение поведения(методы) и состояния(поля) базового класса в производный от него.
В результате этого мы избегаем дублирования кода и процесс исправления ошибок в коде также упрощается.

В джава есть 2-вида наследования:
- наследование классов. Каждый наследник может иметь толко одного родителя.
- наследование интерфейсов. Интерфейс может иметь сколько угодно родителей.

Некоторые тонкие ньюансы по поводу наследования интрефейсов и классов:

Мы имеем два интерфейса с одинаковыми по имени полями. Имплементируем эти интерфейсы на каком-то классе.
Как нам вызвать поля этих интерфейсов?
У нас неоднозначность. Необходимо объект класса привести к нужному интерфейсу.
Class c = new Class();
((Interface1) i).поле;


8.3 Хорошо, что будет если мы имеем метод с одинаковой сигнатурой в интерфейсах и реализуем эти интерфейсы на классе. Как нам в классе реализовать два метода с одинаковой сигнатурой?

Ответ: никак, мы просто реализовываем один общий метод в классе. Это является недостатком, так как нам может потребоваться разная реализация.


8.4 И третий случай: У нас есть класс и интерфейс с одинаковым по сигнатуре методом. Мы наследуемся от этого класса и имплементируем этот интерфейс. Что нам нужно делать?

Ведь необходимо реализовать метод интерфейса по всем правилам.
И вот тут интересно, компилятор не выдает ошибок, так как метод уже у нас реализован в классе родителе.

Инкапсуляция - это свойство которое позволяет закрыть доступ к полям и методам класса другим классам, а предоставлять им доступ только через интерфейс(метод).


9. Для чего нужен оператор «assert» в джава?

Это так называемый оператор утверждений. Он проверяет некое условие, если оно ложно, то генерируется AssertationError
assert status: “message error”;
Тут проверяется булевская переменная “stats”.


10.1 В чем разница между абстрактным классом и интерфейсом? И когда их нужно использовать?

- Абстрактный класс это класс, который помечен как «abstract», он может содержать абстрактные методы, а может их и не содержать.
Экземпляр абстрактного класса нельзя создать.
Класс, который наследуется от абстрактного класса может реализовывать абстрактные методы, а может и не реализовывать, тогда класс наследник должен быть тоже абстрактным. Также если класс наследник переопределяет реализованный в абстрактном классе родители метод, его можно переопределить с модификатором абстракт! Т.е отказаться от реализации. Соответственно данный класс должен быть также абстрактным также.

- Что касается интерфейса, то в нем находятся только абстрактные методы и константы. При реализации интерфейса, класс обязан реализовать все методы интерфейса. Иначе класс должен быть помечен как абстрактный.
Интересный момент, интерфейс может содержать внутренние классы! И НЕабстрактные методы в них.


10.2 Что же использовать Интерфейс или Абстрактный класс?

- Абстрактный класс используется когда нам нужна какая-то реализация по умолчанию.
- Интерфейс используется когда классу нужно указать конкретное поведение.
- Часто интерфейс и абстрактный класс комбинируют, т.е. имплементируют интерфейс в абстрактном классе, чтоб указать поведение и реализацию по умолчанию. Это хорошо видно на примере SWING-а:

AbstractTableModel implements TableModel {}
MyTableModel extends AbstractTableModel {}

Мы создаем свою модель таблицы с определенным поведением и уже с реализацией по умолчанию.


11. Почему в некоторых интерфейсах вообще не определяют методов?

Это так называемые интерфейсы–маркеры.
Они просто указывают что класс относится к определенной группе классов. Например интерфейс Clonable указывает на то, что класс поддерживает механизм клонирования.
Степень абстракции в данном случае доведен до абсолюта. В интерфейсе вообще нет никаких объявлений.


12. Объясните понятие 'переопределение метода' и 'перегрузка метода'?

- Переопределение методов действует при наследовании классов, т.е. в классе наследнике объявлен метод с такой же сигнатурой что и в классе родителе. Значит этот метод переопределил метод своего суперкласса. Несколько ньюансов по этому поводу:
-- Модификатор доступа в методе класса наследника должен быть НЕ хуже чем в классе родителе, иначе будет ошибка компиляции.
-- Описание исключения в переопределенном методе класса наследника должен быть НЕ шире чем в классе родителе, иначе ошибка компиляции.
-- Метод обьявленный как «private» в классе родителе нельзя переопределить!
- Перегрузка методов – это когда в классе есть методы с одинаковым именем, но с разными входными параметрами.


13. Расскажите про Collection framework?

В основе фреймворка лежит два интерфейса, это «Collection» и «Map»

- Сollection расширяет три интерфейса: List, Set, Queue.

- List – хранит упорядоченные елементы (могут быть одинаковые); Имеет такие реализации как LiskedList, ArrayList и Vector:
-- Vector синхронизирован, и по этому в одном потоке, он работает медленней остальных реализаций.
-- ArrayList – его преимущество в навигации по коллекции.
-- LinkedList – Его преимущество в во вставке и удалении элементов в коллекции.
- Set – коллекции, которые не содержат повторяющихся елементов. Основные реализации: HashSet, TreeSet, LinkedHashSet:
-- TreeSet – упорядочивает элементы по их значениям;
-- HashSet – упорядочивает элементы по их хэш ключах, хотя на первый взляд может показаться что элементы хранятся в случайном порядке.
-- LinkedHashSet – хранит элементы в порядке их добавления
- Queue – интерфейс для реализации очереди в джава. Ключи в Мар не могут быть одинаковыми! Основные реализации LinkedList, PriorityQueue. Очереди работают по принципу FIFO – first in first out.
- Map – интерфейс для реализации так называемой карты, где елементы хранятся с ихними ключами. Основные реализации: HashTable, HashMap, TreeMap, LinkedHashMap:
-- HashTable – синхронизированна, объявлена уставревшей.
-- HashMap – порядок елементов рассчитывается по хэш ключу;
-- TreeMap – элементы хранятся в отсортированном порядке
-- LinkedHashMap – элементы хранятся в порядке вставки

Синхронизировать не синхронизированные коллекции и карты можно посредством класса Collections.synchronizedMap(MyMap) / .synchronizedList(MyList)


14. Как сравниваются елементы коллекций?

Для сравнения элементов коллекций используется метод equals() и hashcode();
Эти методы унаследованы от класса Object.
Соблюдается следующий контракт - если наш пользовательский класс переопределяет equals(), то он должен и переопределить hashcode():
- Если два объекта эквивалентны, то и хэш коды этих объектов тоже должны быть равны
- Если поле не используется в equals(), то оно и не должно использоваться в hashcode().


15. Какая основная разница между String, StringBuffer, StringBuilder?

- 'String' – неизменяемый класс (immutable), тоесть для для добавление данных в уже существующую строку, создается новый объект строки.
- 'StringBuffer' и 'StringBuilder' – могут изменятся (mmutable) и добавление строки не такое дорогостоющее с точки зрения памяти. 'StringBuffer' – синхронизированный, 'StringBuilder' – нет. Это их единственное различие.
- Правда если нам нужно сделать подстроку строки, то лучше использовать String, так как ее массив символов не меняется и не создается заново для новой строки. А вот в StringBuffer и StringBuilder для создания подстроки создается новый массив символов.


16. Какова основная разница между передачей по ссылке и по значению?

- В Java параметры в методы передаются по значению, тоесть создаются копии параметров и с ними ведется работа в методе. В случае с примитивными типами, то при передачи параметра сама переменная не будет меняться так как в метод просто копируется ее значение.
- А вот при передачи объекта копируется ссылка на объект, тоесть если в методе мы поменяем состояние объекта, то и за методом состояние объекта тоже поменяется. Но если мы этой копии ссылки попытаемся присвоить новую ссылку на обьект, тогда старая ссылка у нас не изменится!

В случае же кода мы передаем String, то состояние не будет менятся, так как String неизменяемый.


17. Что такое сериализация? Как Вы исключите поля из сериализации? transient что значит?

- Сериализация – это процес чтения или записи объекта. Это процесс сохранения состояния объекта и считывание этого состояния. Для реализации сериализации нужен интерфейс – маркер Serializable.
- Для того чтоб исключить поля из сериализуемого потока, необходимо пометить поле модификатором transient


18. Расскажите про потоки ввода-вывода Java?

Потоки ввода-вывода бывают двух видов:
- байтовый поток (InputStream и OutputStream);
- символный поток (Reader и Writer);

Это все абстрактные классы – декораторы, которым можно добавлять дополнительный функционал, например:
InputStream in = new FileInputStream(new File(“file.txt”));


19.1 Расскажите про клонирование объектов. В чем отличие между поверхностным и глубоким клонированием?

- Чтобы объект можно было клонировать, он должен реализовать интерфейс Cloneable(маркер). Использование этого интерфейса влияет на поведение метода «clone» класс Object. Таким образом 'myObj.clone()' создаст нам клон нашего объекта, но этот клон будет поверхностный.


19.2 Что значит поверхностным?

Это значит что клонируется только примитивные поля класса, ссылочные поля не клонируются!


19.3
 
- Для того, чтоб произвести глубокое клонирование, необходимо в клонируемом классе переопределить метод clone() и в нем произвести клонирование изменяемых полей объекта.


20. В чем разница между 'переменной экземпляра' и 'статической переменной'? Приведите пример?

- Статические переменные инициализируются при загрузке класса класслодером, и не зависят от объекта.
- Переменная экземплра инициализируется при создании класса.
- Например: нам нужна глобальная переменная для всех объектов класса, например число посещений пользователей определенной статьи в интернете. При каждом новом посещении статьи создается новый объект и инкрементируется переменная посещений.


21. Приведите пример когда можно использовать статический метод?

Статические методы могут быть использованы для инициализации статических переменных. Часто статические методы используются в классах утилитах, таких как Collections, Math, Arrrays


22.Какие бывают модификаторы доступа в джава?

- public(используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) – Модификатор доступа общественный, доступен всем.
- protected(используется конструкторах, внутренних классах, методах и полях класса) – Модификатор доступа на уровне пакета и в иерархии наследования
- private(используется конструкторах, внутренних классах, методах и полях класса) – Доступ разрешен только в текущем классе
- friend(используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) - на уровне пакета

Заметьте что protected не равен friend, их нельзя сравнивать!


23. Где и как вы можете использовать закрытый конструктор?

Например в качестве паттерна Синглетон. В том же классе создается статический метод. Где и создается экземпляр класса, конечно если он уже не создан, тогда он просто возвращается методом.


24. Что такое final модификатор? Объясните другие модификаторы.

Нельзя наследоваться от final-класса. Нельзя переопределить final-метод. Нельзя изменить значение final-поля.

- volatile – указывает на то, что поле синхронизировано для нескольких потоков
- synchronized – указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.
- transient – указывает на то, что переменная не подлежит сериализации
- native – говорит о том, что реализация метода написана на другой программной платформе


25. Что такое final, finally и finalize()?

- final – Нельзя наследоваться от final-класса. Нельзя переопределить final-метод. Нельзя изменить сначение final-поля.
- finally – используется при обработке ошибок, вызывается всегда, даже если произошла ошибка(кроме System.exit(0)). Удобно использовать для освобождения ресурсов.
- finalize() – вызывается перед тем как сборщик мусора будет проводить освобождение памяти. Не рекомендуется использовать для освобождения системных ресурсов, так как не известно когда сборщик мусора будет производить свою очистку. Вообще данный метод мало кто использует. Единственно что можно использовать этот метод для закрытия ресурса что должен работать на протяжении всей работы программы и закрываться по ее окончанию. Еще можно использовать метод для защиты от так называемых «дураков», проверять, освобождены ли ресурсы, если нет, то закрыть их.


26.1 Расскажите про модель памяти в джава?

В Джаве память устроена следующим образом, есть 2-вида:
- Куча
- Стек

- В стеке происходит весь процесс выполнения программы, а также хранятся примитивные типы полей и переменных.
- Куча состоит из 'статического контекста' и 'самой кучи':
-- В 'статическом контексте' находятся загружаемые классы.
-- (Перейдем к куче) Куча состоит из двух частей:
--- Так называемая (новая куча) 'молодое поколение'
--- и (старая куча) 'старое поколение'

'Молодое поколение' в свою очередь состоит из двух частей:
- Eden (назовем ее первая) куча
- Survival (выжившая) куча


26.2 Итак, как работает Garbage Collection (сборщик мусора)?

Во-первых что стоит сказать у сборщика мусора есть несколько алгоритмов работы, он не один.


26.3 Когда происходит очистка памяти?

- Если память в Eden (первой) куче полностью заполнена, то туда идет сборщик мусора и делает свою работу..., какую именно - зависит от обстоятельств. Например если в Eden (первой) куче много мусора (т.е. объектов с нулевой ссылкой), то сборщик мусора помечает эти объекты, далее те что остались объекты со ссылками он их переносит в Выжившую кучу, а в первой куче он просто все удаляет.
Ситуация другая… в первой кучи мало мусора, но очень много рабочих объектов. Как поступает в этом случае сборщик мусора?
он помечает мусор, удаляет его и оставшиеся объекты компонует.
- Также следует заметить что при нехватке места в Survival (выжившая) куче, объекты переносятся в старое поколение, там хранятся как правило долго живущие объекты.
- Также следует заметить что сборщик мусора вызывается сам периодически, а не только когда памяти не хватает.

http://hobbytour.com.ua/?cat=43   http://habrahabr.ru/post/112676
-------------------------------   -------------------------------
Области памяти:
- Эдем (Eden) — это область динамической памяти, в которой изначально выделяются все объекты. Многие объекты никогда не покидают этой области памяти.
- Область уцелевших (Survivor) — как правило, в памяти присутствует две области уцелевших. Или же можно считать, что область уцелевших обычно делится пополам. Именно в нее попадают объекты, пережившие «изгнание из Эдема» (отсюда и ее название).
- Хранилище (Tenured) — это область (также называемая «старым поколением»), где оказываются уцелевшие объекты, которые признаются «достаточно старыми» (таким образом, они покидают область уцелевших). Хранилище не очищается в ходе молодой сборки.
- Постоянное поколение памяти (PermGen) — здесь выделяется место для внутренних структур, например для определений классов. Строго говоря, постоянное поколение не входит в состав динамической памяти, обычные объекты сюда никогда не попадают.
-------------------------------


27.1 Расскажите про внутренние классы. Когда вы их будете использовать?

Внутренний класс – это класс, который находится внутри класса или интерфейса. При этом он получает доступ ко всем полям и методам своего внешнего класса.


27.2 Для чего он может применятся?

Например чтобы обеспечить какую-то дополнительную логику класса. Хотя использование внутренних классов усложняет программу, рекомендуется избегать их использование.


27.3 Какие внутренние классы бывают?

- Есть так называемый вложенный (с модификатором static)
- А также есть анонивный внутренний класс.


28. Расскажите про привидение типов. Что такое понижение и повышение типа? Когда вы получаете ClassCastException?

Приведение типов это установка типа переменной или объекта отличного от текущего. В Java есть 2-вида приведения:
- автоматическое
- и НЕавтоматическое

Автоматическое происходит например:
byte -> short -> int -> long -> float -> double
тоесть если мы расширяем тип, то явное преобразование не требуется, приведение происходит автоматически.

Если же мы сужаем, то необходимо явно указывать привидение типа.
В случае же с объектами, то мы можем сделать автоматическое приведение от наследника к родителю, но никак не наоборот, тогда вылетит ClassCastException


29. Чем отличается процесс от потока?

- Процесс - это объект, которому операционная система выделяет уникальное адресное пространство. Это происходит при запуске прораммы.
- Также создается поток в этом процессе. А вернее группа потоков main.


30. Какие способы запуска потоков вы знаете?

- Наследоваться от класса Thread, создать объект и вызвать метод start().
- Имплементировать интерфейс Runnable, создать объект класса Thread и в качестве параметра конструктору передать объект нашего класса.


31. В каких состояниях может быть поток в Java? Как вообще работает поток?

У нас есть текущий поток, в котором выполняется метод main. Этот поток имеет свой стек и этот стек начинается с вызова метода main.
Далее в методе main мы создаем новый поток, что происходит:
- создается новый поток
- и для него выделяется свой стек с первоначальным методом run().
Когда мы запускаем несколько потоков, то мы не можем гарантировать определенный порядок их вызовов. Планированием потоков занимается планировщик потоков JVM, выбирая из пулов потоков поток. Мы даже не можем гарантировать что если первый поток начался выполнятся первым, то он и закончит выполнятся первым, он может закончить выполнятся последним.
Еще такой ньюанс, что поток, который закончил свое выполнение, не может быть повторно запущен! Он находится в состоянии «мертвый», а для запуска нового потока, объект должен находится в состоянии «новый».

Потоки имеют такие состояния:
- новый (это когда только создали экземпляр класса Thread)
- живой или работоспособный (переходит в это состояние после запуска метода start(), но это не означает что поток уже работает! Или же он может перейти в это состояние из состояние работающий или блокированный)
- работающий (это когда метод run() начал выполнятся)
- Ожидающий (waiting) / Заблокированный (blocked) / Спящий(sleeping). Эти состояния характеризуют поток как не готовый к работе. Я объединил эти состояния т.к. все они имеют общую черту – поток еще жив (alive), но в настоящее время не может быть выполнен. Другими словами поток уже не работает, но он может вернутся в рабочее состояние. Поток может быть заблокирован, это может означать что он ждет освобождение каких-то ресурсов. Поток может спать, если встретился метод sleep(long s), или же он может ожидать, если встретился метод wait(), он будет ждать пока не вызовится метод notify() или notifyall().
- мертвый (состояние когда метод run() завершил свою работу)


32. Что значит усыпить поток?

Перевести поток в спящее состояние можно с помощью метода sleep(long ms) ms – время в миллисекундах.
При вызове этого метода, поток переходит в спящее состояние, после сна, поток переходит в пул потоков и находится в состоянии «работоспособный», т.е. не гарантируется что после пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток, так как метод sleep – это статический метод! Вы просто усыпите текущий поток и не более того! Также метод sleep() может возбуждать InterruptedException().


33. Что значит приоритет потока?

Приоритет потока – это число от 1 до 10, в зависимости от которого, планировщик потоков выбирает какой поток запускать. Однако полагаться на приоритеты для предсказуемого выполнения многопоточной программы нельзя!


34. Что делает метод yield()?

Метод yield() пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние «работающий» в состояние «работоспособный». Однако выполнение метода может вообще не произвести никакого эффекта.


35. Расскажите про метод join()?

Метод join() вызывается для того, чтобы привязать текущий поток в конец потока для которого вызывается метод. Тоесть второй поток будет в режиме блокировки пока первый поток не выполнится.


36. Расскажите про синхронизацию потоков? Как это сделать?

Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то объекта, это недопустимо. Для этого необходимо синхронизировать потоки.
Ключевое слово 'synchronized' позволяет это сделать установив в сигнатуре метода. Или же в методе можно описать блок synchronized, только в качестве параметра необходимо передать объект, который будет блокироватся.

Представьте себе ситуацию когда один поток ждет пока разблокируется объект, а если это ждут несколько потоков? Нет гарантии что тот объект что больше всех ждал снятия блокировки будет выполнятся первым.

Статические синхронизированные методы и нестатические синхронизированные методы не будет блокировать друг друга, никогда. Статические методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу.

— wait() – отказывается от блокировки
— остальные методы - сохраняют блокировку


37. Что такое взаимная блокировка ?

Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку на объект В1. В то время как поток А пытается получит блокировку на объект В1, а поток В на А1.


38. Что такое потоки–демоны в Java?

Это потоки, которое работают в фоновом режиме и не гарантируют что они завершатся. Тоеть если все потоки завершились, то поток-демон просто обрывается вместе с закрытием приложения.


39. Может ли объект получить доступ к private-переменной класса? Если, да, то каким образом?

- Вообще доступ у private-переменной класса можно получить только внутри класса, в котором она объявлена. Для доступа из других классов можно применить инкапсуляцию.
- Также доступ к private-переменным можно осуществить через механизм отражений.


40. Как можно уничтожить объект в Java?

Этого нельзя сделать вручную.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(JVM изнутри – организация памяти внутри процесса Java) http://habrahabr.ru/post/84165/
                                                        http://forum.sources.ru/index.php?showtopic=280746

  (Java. Вопросы на собеседовании и ответы) http://wizardjava.com/java/java-voprosy-na-sobesedovanii-i-otvety-chast-1
                                            http://wizardjava.com/java/java-voprosy-na-sobesedovanii-i-otvety-chast-2
  (Операции над примитивными типами в Java) http://www.znannya.org/?view=Java_PrimitiveTypesOp
                                            https://sohabr.net/habr/post/261315/?version=107602
                                            http://www.quizful.net/interview/java/java-interview >> http://www.quizful.net/interview/java/Cz1jySBYuxgy >> http://ru.stackoverflow.com/questions/281650/Побитовые-операции-о-каких-из-них-полезно-знать-программистам-более-высоких >> http://ru.stackoverflow.com/questions/100851/Зачем-нужны-побитовые-операторы-и-что-они-фактически-делают-в-Си
                                            ( http://www.realcoding.net/articles/glava-1-vstroennye-tipy-dannykh-operatsii-nad-nimi.html >> https://github.com/wapmorgan/java_for_beginners_book/blob/master/c2.md >> http://dark-barker.blogspot.com/2012/03/bit-operations-java-pitfalls.html )
                             (Глава 4 Типы) http://www.helloworld.ru/texts/comp/lang/java/java/04.htm
                       (Глава 5. Операторы) http://www.helloworld.ru/texts/comp/lang/java/java/05.htm
(Глава 6. Управление выполнением программы) http://www.helloworld.ru/texts/comp/lang/java/java/06.htm
                          (Глава 7. Классы) http://www.helloworld.ru/texts/comp/lang/java/java/07.htm
(115 Java Interview Questions and Answers) http://www.javacodegeeks.com/2014/04/java-interview-questions-and-answers.html#11
                                           https://github.com/snowdream/115-Java-Interview-Questions-and-Answers/tree/master/en
        (Interview Questions in Core Java) http://www.aucev.edu.in/placementcell/Materials/App3.pdf
(Основные понятия объектно-ориентированного программирования) http://study-java.ru/uroki-java/urok-4-osnovnye-ponyatiya-oop/
                                                              http://danilov-jee.blogspot.ru/2012/10/java.html
(Ответы на вопросы для собеседования по Java SE) http://dr-magic.blogspot.com/2009/01/java-se-1.html
                                                 http://dr-magic.blogspot.com/2009/01/java-se-2.html
                                                 http://dr-magic.blogspot.com/2009/05/java-se-3.html
(Топ-50 интервью вопросов по нитям) http://info.javarush.ru/KapChook/2015/02/15/Перевод-Топ-50-интервью-вопросов-по-нитям-Часть-1-.html
                                    http://info.javarush.ru/translation/2015/02/15/Перевод-Топ-50-интервью-вопросов-по-нитям-Часть-2-.html
(Вопросы на интервью по технологиям Java Spring и Hibernate) http://j4sq.blogspot.com/2012/01/java-spring-hibernate.html
            (Hibernate кэширование на практике и заключение) http://dr-magic.blogspot.com/search/label/Hibernate
       (10 интересных вопросов по Java, которые вам могут задать на собеседовании) http://tproger.ru/translations/10-tricky-core-java-interview-coding
                                             (Топ 10 вопросов о коллекциях в Java) http://info.javarush.ru/translation/2014/06/26/Топ-10-вопросов-о-коллекциях-в-Java.html
(15 вопросов к техническому интервью Java программиста с 5-6 летним опытом работы) http://info.javarush.ru/translation/2014/03/21/15-вопросов-к-техническому-интервью-Java-программиста-с-5-6-летним-опытом-работы-.html
              (Вопросы для java интервью, собеседования: ArrayList) http://javazedxc.blogspot.com/2014/11/arraylist_30.html
                                                (HashSet и HashMap) http://javaoutsource.blogspot.com/2012/10/hashset-hashmap.html
                                                         (hashCode) http://javaoutsource.blogspot.com/2012/11/hashcode.html
                   (Опишите механизм добавления элемента в HashMap) http://www.quizful.net/interview/java/adding-items-to-hashmap
(Вопросы на собеседовании Java программиста. Класс StringTokenizer) http://danilov-jee.blogspot.ru/2013/10/java-stringtokenizer.html
(Java Core. Вопросы к собеседованию) http://info.javarush.ru/translation/2014/02/12/Java-Core-Вопросы-к-собеседованию-ч-1.html
                                     http://info.javarush.ru/translation/2014/02/11/Java-Core-Вопросы-к-собеседованию-ч-2.html
(Java String. Вопросы к собеседованию и ответы на них) http://info.javarush.ru/translation/2014/02/07/Java-String-Вопросы-к-собеседованию-и-ответы-на-них-.html
                                                       http://info.javarush.ru/translation/2014/02/07/Java-String-Вопросы-к-собеседованию-и-ответы-на-них-ч-2.html
(Как HashMap работает в Java?) http://info.javarush.ru/translation/2014/04/27/Как-HashMap-работает-в-Java-.html
(10 советов по многопоточному программированию на Java) http://tproger.ru/translations/10-java-multithread-practices/
 (Тесты по Java) http://ab.kh.ua/java-tests/
(Обзор EasyMock) http://j4sq.blogspot.com/2012/01/easymock.html

(Вопросы на собеседовании ** Базы данных) http://job-interview.ru/questions/database/
                                                    (Топ 11 вопросов по SQL на собеседованиях) http://penteil.com/article/top-11-voprosov-po-sql-na-sobesedovaniyakh
                                                             (Наш вариант теста на знание SQL) http://habrahabr.ru/post/181033/
(Вопросы на собеседовании Java программиста. Разница между LEFT JOIN, RIGHT JOIN и INNER JOIN) http://danilov-jee.blogspot.ru/2013/01/java-left-join-right-join-inner-join.html
(Собеседование SQL вопросы) http://www.quizful.net/interview/sql?page=1

  (Java для белок ** Подготовка к собеседованию на java-программиста (уровень Junior)) http://j4sq.blogspot.com/2012/01/java-junior.html
  (Java для белок ** Подготовка к собеседованию на java-программиста (уровень Middle)) http://j4sq.blogspot.com/2012/01/java-middle.html
(Java для белок ** Подготовка к собеседованию на java-программиста-2 (уровень Middle)) http://j4sq.blogspot.com/2012/01/java-2-middle.html
(исходный код проека combiq.ru - поможет вам подготовиться к собеседованию на позицию Java разработчик) https://github.com/atott/combiq
                                                   (Список вопросов на собеседовании Java программиста) http://danilov-jee.blogspot.com/2013/10/java.html

(GWT Interview questions ** 24 December 2010) http://snsankar.blogspot.com/
=======================================================================================================================================================================================
Стек и куча два разных способа организации памяти.
И если тебе часто требуется переменная в конце стека, то оптимальнее тогда размещать переменные в куче, т.к. не надо постоянно дёргать указатель стека туда-сюда.
Ну и оперция push или pop выполняется быстрее чем считать переменную и занкрементить указатель (*i++).

Стек, это структура данных по принципу "последний вошел - первый вышел". Используется в процессорах в первую очередь для организации вызовов функций, которые как правило вложены друг в друга. Обычно это происходит так: при входе в функцию, в стек помещаются параметры и адрес возврата - адрес следующей за вызовом команды. Сама функция внутри себя еще расширяет стек под локальные переменные. При выходе из функции стек восстанавливается к виду, какой он был до входа в функцию.
В общем, у объектов на стеке время жизни ограничено временем существования данного фрагмента стека, а область видимости ограничена тем, является ли данная область стека сейчас самой "верхней".
А куча - это динамическая память. Ты выделяешь из нее фрагмент нужного размера, и можешь обращаться к ней из любой части программы, имея валидный указатель. Время жизни объектов на куче такое, какое потребуется, они не "умирают" при выходе за область видимости. В большинстве языков ты сам должен очистить выделенную под объект память, в других же это сделает уборщик мусора.

И стек и куча это оперативная память (в х86) И в стеке и в куче можно обратиться к любому участку памяти.
Для доступа в куче к данным, храниться базовый адрес данного куска и смещение нужного байта относительно базового адреса или относительный адрес нужного байта в сегменте данных. Для доступа в стеке к любым данным, хранится вершина стека и смещение нужного байта относительно вершины стека. И в том и в другом случае доступ осуществляется за одно время и выполняется он аппаратно процессором.

А разница в скорости возникает в то время, когда нужно занять/освободить место в памяти. Стек всегда готов к размещению новых данных и всегда готов у удалению данных. А кучей по сути является свободное пространство в памяти и для того чтоб разместить в ней данные, нужно обратиться к менеджеру памяти, менеджер памяти найдет свободное место нужного размера в памяти, зарегистрирует его как занятый и вернет адрес этого блока в программу. При удалении блока данных из кучи так же нужно обратиться к менеджеру памяти, менеджер памяти пометит данный кусок памяти как свободный. 
и плюс разный срок хранения данных: в стеке пока выполняется данная процедура, а в куче пока выполняется данный процесс 



Интерфейс-маркер гарантирует соблюдение контракта (а именно) что класс наследник будет принадлежать конкретной группе-пакету - это обозначает что такой класс будет обеспечен поддержкой ожидаемого функционала...



если разработчик явно рекомендует, что надо выбрать что-то другое (или HashMap или ConcurrentHashMap вместо Hashtable), то это - явный признак того, что класс устарел, и даже без явных указаний типа obsolete или deprecated.
если не требуется потоко-безопасная имплементация, то рекомендуется использовать HashMap.
ConcurrentHashMap - а если не десаред, то соответсвенно не рекомендуется.

"если класс устаревший, то пишется или replaced (в случае нового АПИ), или (strongly) recommended;" - это где так написано, не подкинешь ссылку?

Пряморукий подход:
- внутри одного потока: HashMap, HashSet, LinkedList, ArrayDeque, PriorityQueue, ArrayList, строки в StringBuilder
- чтение запись с разных потоков: ConcurrentHashMap, Collections.newSetFromMap(new ConcurrentHashMap<Object,Boolean>()), CopyOnWriteArrayList, очереди из java.util.concurrent 
Криворукий подход - недосинхронизированные(полуфабрикаты) и что более важно НЕ ОПТИМИЗИРОВАННЫЕ(в ConcurrentHashSet неcколько мониторов, а не один общий) для работы из разных потоков; эти классы синхронизируют только отдельные операции, и используют в качестве мониторов себя любимых(поэтому, если схема check-then-act нужно делать synchonized(ref) { чтение/копирование состояния(); действие() }):
- Vector, Stack, Hashtable
- Collections.synchronizedSet() , Collections.synchronizedCollection(), Collections.synchronizedList()
- строки в StringBuffer

доступ к приватному полю можно получить только в классе, в котором объявлено это поле или через механизм рефлексии. В классе наследнике Вы не сможете напрямую получить доступ к приватному полю. Обычно для доступа к приватному полю делают getter метод.

volatile запрещает потоку создавать локальные копии переменной.

https://www.youtube.com/watch?v=Z0JMABjXnww
https://www.youtube.com/watch?v=IyPaSUFrhaM
https://github.com/atott/combiq
http://ab.kh.ua/java-tests/
http://vk.com/topic-55725362_28925642
http://vk.com/topic-55725362_28931513


( http://www.quizful.net/user/Templar555 )
( http://www.quizful.net/post/Using-Map-in-Jave )
http://becomejavasenior.com/blog/2015/07/01/327-interview-questions-java-developer/

https://github.com/JobTest/Algorithm/blob/master/90A1F50E-8D31-4FB6-A113-3655E2D64BD6.jpg
http://genius.pstu.ru/file.php/1/pupils_works/Bursuk.pdf


(gwt вопросы)
http://snsankar.blogspot.com/
http://ru.stackoverflow.com/questions/tagged/gwt/
http://archive.is/dxV40
http://habrahabr.ru/post/132996/
http://www.quizful.net/test/gwt-google-web-toolkit

http://habrahabr.ru/post/186350/
http://habrahabr.ru/post/192262/
http://habrahabr.ru/post/218731/
https://github.com/jet-black/gwt-java8-demo
http://resty-gwt.github.io/
https://github.com/WeTheInternet/gwt-sandbox/releases/tag/Java8%2BJsInterop








