
* [10 интересных вопросов по Java, которые вам могут задать на собеседовании](http://tproger.ru/translations/10-tricky-core-java-interview-coding)
* [Синхронизация потоков, блокировка объекта и блокировка класса](http://info.javarush.ru/translation/2014/10/27/Синхронизация-потоков-блокировка-объекта-и-блокировка-класса.html)
  [http://www.sql.ru/forum/297663/sinhronizaciya-i-vyzov-metodov](http://www.sql.ru/forum/297663/sinhronizaciya-i-vyzov-metodov)


Потоки
======

> Как известно, основная проблема при работе с потоками, - это атомарность (обеспечить безопасный доступ к критическим секциям для всех и каждого потока).

> Каждый поток может выполняться на отдельном процессоре - а значит что для каждого потока выделяется (собственный) "локальный кеш потока".
> А значит, для критических секций в многопоточной программе выделяется: "основная память" и "локальный кеш потока".
> То есть, между "отдельным процессором" (где выполняется поток) и "критической секцией" (где выделена основная память) стоит "локальный кеш потока".
> И поэтому данные из "отдельного процессора" в "основную память" не могут попасть за 1-проход - такая операция уже не есть атомарная.

'volatile' - гарантированую атомарность можно получить на переменные (точнее на ссылку переменной, но на сами данные - нет) - исключает посредников "локальный кеш потока" и обеспечивает прямой доступ из потока к "основной памяти" за 1-проход.
Для обмена даннми между потоками - атомарные поля гарантируют что за каждый 1-проход переменная будет иметь прямую видимость (одинаково) для всех потоков.

'synchronized' - гарантированую атомарность можно получить на тело и функцию.


Синхронизация потоков
=====================

> Синхронизацию потоков можно условно разделить на 5-видов:
1. синхронизацию на уровне объектов (обычная атомарность...)
2. синхронизацию на уровне классов (атомарность для статических функций и блоков...)
3. синхронизацию относительно 1-объекта (лок для организации порядка потоков... - лучше использовать библиотечные утилиты вместо wait/notify)
4. атомарность для переменных (для обмена сообщениями между потоками...)
5. класс-данных (обеспечивает целостность данных... через атомарные функции 'get() / set()'...)


1. синхронизацию на уровне объектов:
Класс - один; Объектов (экземпляров класса) - много; Потоков которые используют каждый этот объект (экземпляр класса) - много;
(один класс * много объектов * много потоков)
---------------------------------------------
Одновременно с каждым объектом (или статическим классом) могут паралельно работать (пересекать их) много потоков.
'synchronized' создает (новый) эксклюзивный объект-монитор, относительно того (существующего) объекта чьи функции мы синхронизируем, И включает в этот (новый) эксклюзивный объект-монитор только синхронизированные функции и блоки из (существующего) объекта.
Обычно в классе синхронизируется только 1-функция (это нормально).
Каждый 'монитор' имеет инструмент-блокировку, который использует поток чтобы изолироваться от других потоков.
Объект-монитор работает по принципу - зашел в кабинку и заперся изнутри (если изнутри запереть дверь тогда снаружи больше никто несможет попасть и отпереть эту дверь), то есть, это есть такой себе щит, который блокирует-защищает доступ к синхронизируемым методам и блокам от других потоков.
Таким способом-блокировки достигается атомарность для блоков и функций.
Поэтому говорят, что каждый объект-монитор может захватить только один поток (и не более) И поэтому если каждый объект-монитор имеет несколько синхронизированных блоков или функций - при этом всегда, в какой-то момент времени только к одной функции или одному блоку можно получить доступ (одновременно нельзя получить доступ к нескольким функциям и блокам одного объекта-монитора).
Объект-монитор можно представить эксклюзивной копией (существующего) объекта - щит который защищает синхронизированные функции и методы от доступа множества поток И пропускает (фильтрует) только один поток.
Но 'synchronized' негарантирует порядок доступа для потоков к функциям и методам. Этот порядок доступа для потоков к функциям и методам зависит только от приоритета потока (то есть, после освобождения монитора первым будет первый попавшийся поток или же тот поток, который имеет высокий приоритет).
Объект-монитор используется только для обычных классов и обычно синхронизируется только 1-функция или блок.
(Чтобы просто получить атомарность  на функцию или блок)

2. синхронизацию на уровне классов
----------------------------------
Сам по себе статический класс уже обеспечивает атомарность для экземпляра класса (объекта) - ограничивает не более одного экземпляра класса (объекта).
Но в многопоточном программе теряется целостнолсть данных на НЕатомарных операциях...
В остальном, класс-монитор работает аналогично объекту монитору...
класс-монитор используется только для статических классов и обычно синхронизируется только 1-функция или блок.
(Чтобы просто получить атомарность  на функцию или блок)

3. лок (синхронизацию относительно 1-объекта)
---------------------------------------------
В предыдущих случаях, монитором объекта или класса для функции и блока, является сам объект или класс внутри которого объявлена эта функция или блок ('this' или '...class').
Лок - это когда объектом-монитора для функции и блока является совсем другой объект (который не имеет отношения к структуре где объявлена эта функция или блок).
Такой специальный объект-монитора 'лок' синхронизируется для нескольких функций или блоков.
Используется 'лок' когда требуется организовать строгий порядок между потоками (которым нужен доступ к функциям и блокам, это не просто атомарность...)
Например: построение очереди сообщений (здесь имеет значение в каком порядке сообщение положили и вытащили из очереди - сначала обрабатываются старые сообщения, а потом новые сообщения...)
Для построения лок-ов применяется структура из 'wait() / notify()'. Но поскольку это имеет высокую вероятность ошибок - рекомендуется для лок-ов использовать утилиты из библиотеки 'concurrency', которые гарантировано исключают ошибки.
Лок-объектом-монитора (желательно) должен быть с сигнатурой 'final' - потому как при изменении/удалении объекта потеряется ранее захваченая синхронизация...

4. атомарность для переменных
-----------------------------
Поскольку в многопоточной программе нет атомарных операций (любая атомарная операция не является прямой для работы с памятью и поэтому неможет быть атомарной)
'volatile' - гарантированую атомарность можно получить на переменные (точнее на ссылку переменной, но на сами данные - нет) - исключает посредников "локальный кеш потока" и обеспечивает прямой доступ из потока к "основной памяти" за 1-проход.
Для обмена сообщениями между потоками - атомарные поля гарантируют что за каждый 1-проход переменная будет иметь прямую видимость (одинаково) для всех потоков.

5. класс-данных
---------------
Считается хорошим тоном программирования отделять поведения программы от состояния программы:
* Поведения программы - состоит из интерфейса (поскольку всегда удобно концентрироваться на функционале чтобы неотвлекаться на его имплементацию) и его имплементации (реализация)...
* Состояние программы - (класс data) чтобы исключить зависимость состояния программы от его поведения (это позволяет рахзработчику концентрироваться только на точечной задаче по реализации функционала...)
Так вот, чтобы максимально обеспечить целостность данных, в классе data функции сводаться к атомарным операциям (это всегда удобно иметь прямую видимость для многопоточной программы за 1-проход)...

Простые (атомарные) операции - которые выполняются за одно действие (за 1-проход) - такие операции являются атомарными.
Например: методы чтения-записи 'get() / set()'. Классы которые имеют только 'get() / set()' методы являются бинами - основная задача бинов обеспечить целостность данных на уровне атомарных операций.










